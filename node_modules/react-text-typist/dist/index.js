'use strict';



function ___$insertStyle(css) {
    if (!css || typeof window === 'undefined') {
        return;
    }
    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
}

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

___$insertStyle("@keyframes blink {\n  50% {\n    opacity: 1;\n  }\n}");

var Typer = function (_a) {
    var sentences = _a.sentences, _b = _a.startDelay, startDelay = _b === void 0 ? 0 : _b, _c = _a.cursorDelay, cursorDelay = _c === void 0 ? startDelay : _c, _d = _a.className, className = _d === void 0 ? '' : _d, _e = _a.cursorClassName, cursorClassName = _e === void 0 ? '' : _e, _f = _a.cursorColor, cursorColor = _f === void 0 ? '' : _f, _g = _a.cursorBlinkSpeed, cursorBlinkSpeed = _g === void 0 ? 700 : _g, _h = _a.showCursor, showCursor = _h === void 0 ? true : _h, _j = _a.hideCursorOnFinish, hideCursorOnFinish = _j === void 0 ? false : _j, _k = _a.cursorSmooth, cursorSmooth = _k === void 0 ? false : _k, _l = _a.typingSpeed, typingSpeed = _l === void 0 ? 80 : _l, _m = _a.deletingSpeed, deletingSpeed = _m === void 0 ? 30 : _m, _o = _a.pauseTime, pauseTime = _o === void 0 ? 1000 : _o, _p = _a.loop, loop = _p === void 0 ? true : _p, _q = _a.style, style = _q === void 0 ? {} : _q, _r = _a.defaultText, defaultText = _r === void 0 ? '' : _r;
    var _s = React.useState(defaultText), text = _s[0], setText = _s[1];
    var _t = React.useState(false), isDeleting = _t[0], setIsDeleting = _t[1];
    var _u = React.useState(0), loopNum = _u[0], setLoopNum = _u[1];
    var _v = React.useState(typingSpeed), writingSpeed = _v[0], setWritingSpeed = _v[1];
    var mountedRef = React.useRef(false);
    var refText = React.useRef(text);
    var refIsDeleting = React.useRef(isDeleting);
    var refLoopNum = React.useRef(loopNum);
    var refWritingSpeed = React.useRef(writingSpeed);
    var refTimer = React.useRef(0);
    var timer1 = React.useRef(0);
    var timer2 = React.useRef(0);
    var timer3 = React.useRef(0);
    var refIsGoingToDelete = React.useRef(false);
    var refIsFinished = React.useRef(false);
    clearTimeout(refTimer.current);
    refText.current = text;
    refIsDeleting.current = isDeleting;
    refLoopNum.current = loopNum;
    refWritingSpeed.current = writingSpeed;
    React.useEffect(function () {
        mountedRef.current = true;
        return function () {
            mountedRef.current = false;
            clearTimeout(refTimer.current);
            clearTimeout(timer1.current);
            clearTimeout(timer2.current);
            clearTimeout(timer3.current);
        };
    }, []);
    var handleType = React.useCallback(function () {
        var i = refLoopNum.current % sentences.length;
        var fullText = sentences[i];
        setText(refIsDeleting.current
            ? fullText.substring(0, refText.current.length - 1)
            : fullText.substring(0, refText.current.length + 1));
        if (!refIsDeleting.current && refText.current === fullText && !refIsGoingToDelete.current) {
            refIsGoingToDelete.current = true;
            timer1.current = window.setTimeout(function () {
                setIsDeleting(true);
                setWritingSpeed(deletingSpeed);
                refIsGoingToDelete.current = false;
            }, pauseTime);
        }
        else if (refIsDeleting.current && refText.current === '') {
            setIsDeleting(false);
            setWritingSpeed(typingSpeed);
            setLoopNum(refLoopNum.current + 1);
        }
        if (loop || i !== sentences.length - 1 || refText.current.length !== fullText.length) {
            if (refIsGoingToDelete.current) {
                timer2.current = window.setTimeout(function () {
                    refTimer.current = window.setTimeout(handleType, refWritingSpeed.current);
                }, pauseTime);
            }
            else {
                refTimer.current = window.setTimeout(handleType, refWritingSpeed.current);
            }
        }
        else {
            refIsFinished.current = true;
        }
    }, [deletingSpeed, loop, pauseTime, typingSpeed, sentences]);
    React.useEffect(function () {
        timer3.current = window.setTimeout(function () {
            if (!mountedRef.current) {
                return;
            }
            handleType();
        }, startDelay);
    }, [handleType, startDelay]);
    var styledSpan = React.useMemo(function () { return ({
        opacity: 0,
        visibility: showCursor ? 'visible' : 'hidden',
        color: cursorColor,
        animation: "blink ".concat(cursorBlinkSpeed, "ms ").concat(cursorSmooth ? '' : 'steps(1)', " infinite"),
        animationDelay: "".concat(cursorDelay, "ms"),
    }); }, [cursorBlinkSpeed, cursorColor, cursorDelay, cursorSmooth, showCursor]);
    return (React__default['default'].createElement("span", { style: style },
        React__default['default'].createElement("span", { className: className }, text),
        !(refIsFinished.current && hideCursorOnFinish) && (React__default['default'].createElement("span", { className: "typist-cursor ".concat("".concat(cursorClassName, " ").concat(className)), style: styledSpan }, "|"))));
};

module.exports = Typer;
//# sourceMappingURL=index.js.map
